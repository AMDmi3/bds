#version 330 core

layout (points) in;
layout (triangle_strip, max_vertices = 36) out;

flat in int out_id[];

#define MAX_NUM_TOTAL_LIGHTS 1
struct light
{
    vec4 color;
    vec4 position;
    vec4 power;
};

layout(std140) uniform light_block
{
    light lights[MAX_NUM_TOTAL_LIGHTS];
    int size;
} light_buffer;

#define MAX_NUM_TOTAL_MATRIX 2
layout(std140) uniform matrix_block
{
    mat4 matrix[MAX_NUM_TOTAL_MATRIX];
    int size;
} matrix_buffer;

vec4 points[36] = {
    vec4(-0.5, -0.5, -0.5, 0.0), //0
    vec4(0.5, -0.5, 0.5, 0.0),   //1
    vec4(-0.5, -0.5, 0.5, 0.0),  //2
    vec4(0.5, 0.5, 0.5, 0.0),    //3
    vec4(-0.5, 0.5, -0.5, 0.0),  //4
    vec4(-0.5, 0.5, 0.5, 0.0),   //5
    vec4(-0.5, 0.5, 0.5, 0.0),   //6
    vec4(-0.5, -0.5, -0.5, 0.0), //7
    vec4(-0.5, -0.5, 0.5, 0.0),  //8
    vec4(-0.5, 0.5, -0.5, 0.0),  //9
    vec4(0.5, -0.5, -0.5, 0.0),  //10
    vec4(-0.5, -0.5, -0.5, 0.0), //11
    vec4(0.5, -0.5, -0.5, 0.0),  //12
    vec4(0.5, 0.5, 0.5, 0.0),    //13
    vec4(0.5, -0.5, 0.5, 0.0),   //14
    vec4(-0.5, -0.5, 0.5, 0.0),  //15 
    vec4(0.5, 0.5, 0.5, 0.0),    //16
    vec4(-0.5, 0.5, 0.5, 0.0),   //17
    vec4(-0.5, -0.5, -0.5, 0.0), //0
    vec4(0.5, -0.5, -0.5, 0.0),  //18
    vec4(0.5, -0.5, 0.5, 0.0),   //1
    vec4(0.5, 0.5, 0.5, 0.0),    //3
    vec4(0.5, 0.5, -0.5, 0.0),   //19
    vec4(-0.5, 0.5, -0.5, 0.0),  //4
    vec4(-0.5, 0.5, 0.5, 0.0),   //6
    vec4(-0.5, 0.5, -0.5, 0.0),  //20
    vec4(-0.5, -0.5, -0.5, 0.0), //7
    vec4(-0.5, 0.5, -0.5, 0.0),  //9
    vec4(0.5, 0.5, -0.5, 0.0),   //21
    vec4(0.5, -0.5, -0.5, 0.0),  //10
    vec4(0.5, -0.5, -0.5, 0.0),  //12
    vec4(0.5, 0.5, -0.5, 0.0),   //22
    vec4(0.5, 0.5, 0.5, 0.0),    //13
    vec4(-0.5, -0.5, 0.5, 0.0),  //15
    vec4(0.5, -0.5, 0.5, 0.0),   //23
    vec4(0.5, 0.5, 0.5, 0.0)     //16
};

vec3 normals[36] = {
    vec3(0.0, -1.0, 0.0), //0
    vec3(0.0, -1.0, 0.0), //1
    vec3(0.0, -1.0, 0.0), //2
    vec3(0.0, 1.0, 0.0),  //3
    vec3(0.0, 1.0, 0.0),  //4
    vec3(0.0, 1.0, 0.0),  //5
    vec3(-1.0, 0.0, 0.0), //6
    vec3(-1.0, 0.0, 0.0), //7
    vec3(-1.0, 0.0, 0.0), //8
    vec3(0.0, 0.0, -1.0), //9
    vec3(0.0, 0.0, -1.0), //10
    vec3(0.0, 0.0, -1.0), //11
    vec3(1.0, 0.0, 0.0),  //12
    vec3(1.0, 0.0, 0.0),  //13
    vec3(1.0, 0.0, 0.0),  //14
    vec3(0.0, 0.0, 1.0),  //15
    vec3(0.0, 0.0, 1.0),  //16
    vec3(0.0, 0.0, 1.0),  //17
    vec3(0.0, -1.0, 0.0), //0
    vec3(0.0, -1.0, 0.0), //18
    vec3(0.0, -1.0, 0.0), //1
    vec3(0.0, 1.0, 0.0),  //3
    vec3(0.0, 1.0, 0.0),  //19
    vec3(0.0, 1.0, 0.0),  //4
    vec3(-1.0, 0.0, 0.0), //6
    vec3(-1.0, 0.0, 0.0), //20
    vec3(-1.0, 0.0, 0.0), //7
    vec3(0.0, 0.0, -1.0), //9
    vec3(0.0, 0.0, -1.0), //21
    vec3(0.0, 0.0, -1.0), //10
    vec3(1.0, 0.0, 0.0),  //12
    vec3(1.0, 0.0, 0.0),  //22
    vec3(1.0, 0.0, 0.0),  //13
    vec3(0.0, 0.0, 1.0),  //15
    vec3(0.0, 0.0, 1.0),  //23
    vec3(0.0, 0.0, 1.0)   //16
};

vec2 uvs[36] = {
    vec2(1.0, 0.0), //0
    vec2(0.0, 1.0), //1
    vec2(0.0, 0.0), //2
    vec2(1.0, 0.0), //3
    vec2(0.0, 1.0), //4
    vec2(0.0, 0.0), //5
    vec2(1.0, 0.0), //6
    vec2(0.0, 1.0), //7
    vec2(0.0, 0.0), //8
    vec2(1.0, 0.0), //9
    vec2(0.0, 1.0), //10
    vec2(0.0, 0.0), //11
    vec2(0.0, 0.0), //12
    vec2(1.0, 1.0), //13
    vec2(0.0, 1.0), //14
    vec2(1.0, 0.0), //15
    vec2(0.0, 1.0), //16
    vec2(0.0, 0.0), //17
    vec2(1.0, 0.0), //0
    vec2(1.0, 1.0), //18
    vec2(0.0, 1.0), //1
    vec2(1.0, 0.0), //3
    vec2(1.0, 1.0), //19
    vec2(0.0, 1.0), //4
    vec2(1.0, 0.0), //6
    vec2(1.0, 1.0), //20
    vec2(0.0, 1.0), //7
    vec2(1.0, 0.0), //9
    vec2(1.0, 1.0), //21
    vec2(0.0, 1.0), //10
    vec2(0.0, 0.0), //12
    vec2(1.0, 0.0), //22
    vec2(1.0, 1.0), //13
    vec2(1.0, 0.0), //15
    vec2(1.0, 1.0), //23
    vec2(0.0, 1.0) //16
};

out vec2 out_uv;
out vec4 out_color;

vec2 select_uv(vec2 uv, const int id)
{
    // stone
    if (id == 0)
    {
        uv *= 0.248;
        uv.x += 0.251;
        uv.y += 0.751;
    }
    // sand
    else if (id == 1)
    {
        uv *= 0.248;
        uv.x += 0.501;
        uv.y += 0.751;
    }
    // lava
    else if (id == 2)
    {
        uv *= 0.248;
        uv.x += 0.251;
        uv.y += 0.501;
    }
    // wood
    else if (id == 3)
    {
        uv *= 0.248;
        uv += 0.751;
    }
    // dirt
    else if (id == 4)
    {
        uv *= 0.248;
        uv.x += 0.001;
        uv.y += 0.501;
    }
    // grass
    else if (id == 5)
    {
        uv *= 0.248;
        uv.x += 0.001;
        uv.y += 0.751;
    }
    // water
    else if (id == 6)
    {
        uv *= 0.248;
        uv += 0.501;
    }
    // sulphur
    else if (id == 7)
    {
        uv *= 0.248;
        uv.x += 0.751;
        uv.y += 0.501;
    }

    return uv;
}

void emit_point(const vec4 vertex, const vec3 normal, const vec2 uv)
{
    // Get the model matrix from the uniform buffer
    mat4 pv = matrix_buffer.matrix[0];

    // Create next vertex
    gl_Position = pv * vertex;

    // Initialize reference color
    vec4 color = vec4(0, 0, 0, 1.0);

    // For all lights in the scene
    for(int i = 0; i < light_buffer.size; i++)
    {
        // Calculate the light direction in world space
        vec4 light_direction = normalize(light_buffer.lights[i].position - vertex);

        // Calculate the diffuse lighting in world space
        float cos_theta = clamp(dot(normal, light_direction.xyz), 0, 1);

        // Calculate ambient, diffuse and specular
        float ambient = light_buffer.lights[i].power.x;
        float diffuse = light_buffer.lights[i].power.y * cos_theta;

        // Calculate the output color
        color += light_buffer.lights[i].color * (ambient + diffuse);
    }

	// Pass texture coordinates to fragment shader
	out_uv = select_uv(uv, out_id[0]);

    // Pass the color to the fragment shader
    out_color = vec4(color.rgb, light_buffer.lights[0].power.a);

    // Emit this vertex
    EmitVertex();
}

void make_triangle(const int i1, const int i2, const int i3, const vec4 p)
{
    emit_point(points[i1] + p, normals[i1], uvs[i1]);
    emit_point(points[i2] + p, normals[i2], uvs[i2]);
    emit_point(points[i3] + p, normals[i3], uvs[i3]);

    // Emit this triangle
    EndPrimitive();
}

void main(void)
{
    // Create a cube where the input point is
    for(int i=0; i<36; i+=3)
    {
        make_triangle(i, i + 1, i + 2, gl_in[0].gl_Position);
    }
}
