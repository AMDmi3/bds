#version 330 core

layout (location = 0) in vec4 position;

#define MAX_NUM_TOTAL_LIGHTS 1
struct light
{
    vec4 color;
    vec4 position;
    vec4 power;
};

layout(std140) uniform light_block
{
    light lights[MAX_NUM_TOTAL_LIGHTS];
    int size;
} light_buffer;

#define MAX_NUM_TOTAL_MATRIX 165
layout(std140) uniform matrix_block
{
    mat4 matrix[MAX_NUM_TOTAL_MATRIX];
    int size;
} matrix_buffer;

uniform vec4 camera_position;
out vec3 out_color;

void main(void)
{
	// Get the proj_view matrix from the uniform buffer
	mat4 pv = matrix_buffer.matrix[0];
	float scale = camera_position.w;

	// Set particle size by distance from camera
	float len = length(camera_position.xyz - position.xyz);
	gl_PointSize = scale / (len + 1.0);

	const float g0 = 0.0;
	const float g1 = 0.3;
	const float g2 = 0.5;
	const float g3 = 0.6;
	const float g4 = 0.75;
	const float f1 = 1.0;
	const float f2 = 2.0;
	const float f3 = 3.0;
	const float f4 = 5.0;
	if(len > g0 && len < g1)
	{
		// Range [0.5 - 0.75]
		float d = 0.833 * len + 0.5;
		
		// Bright red
		out_color = vec3(d * 8.0, d * 2.666, d * 1.666);
	}
	else if(len > g1 && len < g2)
	{
		// Range [0.0 - 1.0]
		float d = 5.0 * len - 1.5;
		
		// Red
		out_color = vec3(d * 3.0, d * 0.666, d * 0.666);
	}
	else if(len >= g2 && len < g3)
	{
		// Range [0.5 - 1.0]
		float d = 5.0 * len - 2.0;
		
		// Yellow
		out_color = vec3(d * 1.5, d, d * 0.5);
	}
	else if(len >= g3 && len < g4)
	{
		// Range [0.0 - 0.25]
		float black = -len + 0.75;
		
		// Black
		out_color = vec3(black, black, black);
	}
	else if(len < f1)
	{
		// Range [0.5 - 0.75]
		float d = len - 0.25;
		
		// Bright red
		out_color = vec3(d * 8.0, d * 2.666, d * 1.666);
	}
	else if(len >= f1 && len < f2)
	{
		// Range [0.0 - 1.0]
		float d = len - 1.0;
		
		// Red
		out_color = vec3(d * 3.0, d * 0.666, d * 0.666);
	}
	else if(len >= f2 && len < f3)
	{
		// Range [0.5 - 1.0]
		float d = 0.5 * len - 0.5;
		
		// Yellow
		out_color = vec3(d * 1.5, d, d * 0.5);
	}
	else if(len >= f3 && len < f4)
	{
		// Range [0.0 - 0.25]
		float black = -0.125 * len + 0.625;
		
		// Black
		out_color = vec3(black, black, black);
	}

	// Initialize reference color
    vec3 color = vec3(0.0, 0.0, 0.0);

    // For all lights in the scene
    for(int i = 0; i < light_buffer.size; i++)
    {
        // Calculate the light direction in world space
        vec3 light_direction = (light_buffer.lights[i].position - position).xyz;
		float d = 1.0 / length(light_direction);

        // Calculate ambient, diffuse and specular
        float ambient = light_buffer.lights[i].power.x;
		float diffuse = light_buffer.lights[i].power.y * d;

        // Calculate the output color
        color += light_buffer.lights[i].color.xyz * (ambient + diffuse);
    }

	out_color += color;

	// Calculate transformed position
	gl_Position =  pv * position;
}
