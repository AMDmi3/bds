#version 330 core

layout (location = 0) in vec4 position;

#define MAX_NUM_TOTAL_LIGHTS 1
struct light
{
    vec4 color;
    vec4 position;
    vec4 power;
};

layout(std140) uniform light_block
{
    light lights[MAX_NUM_TOTAL_LIGHTS];
    int size;
} light_buffer;

#define MAX_NUM_TOTAL_MATRIX 115
layout(std140) uniform matrix_block
{
    mat4 matrix[MAX_NUM_TOTAL_MATRIX];
    int size;
} matrix_buffer;

out vec4 out_color;

void main(void)
{
	// Get the proj_view matrix from the uniform buffer
	mat4 pv = matrix_buffer.matrix[0];
	vec4 camera_position = matrix_buffer.matrix[2][3];
	float scale = camera_position.w;
	camera_position.w = 1.0;

	// Set particle size by distance from camera
	float len = length(camera_position - position);
	gl_PointSize = scale / (len + 1.0);

	// Black
	float f0 = 0.0;
	float f1 = 0.25;
	float f2 = 0.5;
	float f3 = 1.0;
	if(len > f0 && len < f1)
	{
		// Range [0.0 - 0.125]
		float black = 0.50 * len;
		
		// Black
		out_color = vec4(black, black, black, 1.0);
	}
	else if(len > f1 && len < f2)
	{
		// Range [0.0 - 1.0]
		float d = 4.0 * len - 1.0;
		
		// Yellow
		out_color = vec4(d * 1.5, d, d * 0.5, 1.0);
	}
	else if(len >= f2 && len < f3)
	{
		// Range [0.5 - 1.0]
		float d = len;
		
		// Red
		out_color = vec4(d * 3.0, d * 0.666, d * 0.666, 1.0);
	}
	else if(len >= 1.0)
	{
		// Range [0.5 - 0.75]
		float d = clamp(0.5 * len, 0.5, 0.75);
		
		// Bright red
		out_color = vec4(d * 8.0, d * 2.666, d * 1.666, 1.0);
	}

	// Initialize reference color
    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

    // For all lights in the scene
    for(int i = 0; i < light_buffer.size; i++)
    {
        // Calculate the light direction in world space
        vec4 light_direction = light_buffer.lights[i].position - position;
		float d = 1.0 / length(light_direction);

        // Calculate ambient, diffuse and specular
        float ambient = light_buffer.lights[i].power.x;
		float diffuse = light_buffer.lights[i].power.y * d;

        // Calculate the output color
        color += light_buffer.lights[i].color * (ambient + diffuse);
    }

	out_color += color;

	// Calculate transformed position
	gl_Position =  pv * position;
}
